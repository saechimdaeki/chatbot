{"_id":"@slack/rtm-api","_rev":"10-6018a2bfb4ec6881bbf521bf9371828a","name":"@slack/rtm-api","dist-tags":{"latest":"5.0.3"},"versions":{"5.0.0":{"name":"@slack/rtm-api","version":"5.0.0","description":"Official library for using the Slack Platform's Real Time Messaging API","author":{"name":"Slack Technologies, Inc."},"license":"MIT","keywords":["slack","rtm-api","bot","client","http","websocket","api","proxy","state","connection"],"main":"dist/index.js","types":"./dist/index.d.ts","engines":{"node":">= 8.9.0","npm":">= 5.5.1"},"repository":{"type":"git","url":"git+https://github.com/slackapi/node-slack-sdk.git"},"homepage":"https://slack.dev/node-slack-sdk/rtm-api","publishConfig":{"access":"public"},"bugs":{"url":"https://github.com/slackapi/node-slack-sdk/issues"},"scripts":{"prepare":"npm run build","build":"npm run build:clean && tsc","build:clean":"shx rm -rf ./dist","lint":"tslint --project .","test":"npm run build && echo \"Tests are not implemented.\" && exit 0"},"dependencies":{"@slack/logger":"^1.0.0","@slack/web-api":"^5.0.0","@types/node":">=8.9.0","@types/p-queue":"^2.3.2","@types/ws":"^5.1.1","eventemitter3":"^3.1.0","finity":"^0.5.4","p-cancelable":"^1.1.0","p-queue":"^2.4.2","ws":"^5.2.0"},"devDependencies":{"shx":"^0.3.2","tslint":"^5.13.1","tslint-config-airbnb":"^5.11.1","typescript":"^3.3.3333"},"gitHead":"891307eb5f1625f68b72e4c242ba749a7d6cb996","_id":"@slack/rtm-api@5.0.0","_nodeVersion":"10.15.1","_npmVersion":"lerna/3.13.1/node@v10.15.1+x64 (darwin)","dist":{"integrity":"sha512-C1phWQwa1b2H1VePWGYzs4QuFOflW4l4x/1EuquUiZ9WnvzSLFNjmhocIv4ymZmEOdzteapZG/k0S0NbhYP8RA==","shasum":"094d66740bfa6b80f6a37f135099146e969c8622","tarball":"https://registry.npmjs.org/@slack/rtm-api/-/rtm-api-5.0.0.tgz","fileCount":23,"unpackedSize":97212,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcnURBCRA9TVsSAnZWagAA48IP/iIsQfHkGcuzPMm/QowV\nMQ9FYdxMbHSOdizdf8kUszH3JKUESSFSJpaoXNALjzzyurt7QL39BroX1lMg\n5CmDCn0NnNeDtw1SyAubmJKUAHnP6R6ZBhyD523bG5HYBnRwVI3FiZFKLU27\nkuXddTVZyOOuFAp3YkveyPPOI0pFeEhu/bdsjsDMHBbCR7ix+9SfDvXu00pm\nVYc3MwMlhFdDHMdg/CNm7AgaoigeIdXYagAs1P6mQS3x88m2UUkgbRJUG3Ah\nvqId60cDD+kwv2ucVcLC5LCbjp3/c9Q06KLIBWG3lfYjaFSN34AUyu+cohg9\nJT+f5VlzKkZF3QrTe8eGzbu1hS28qARVtxfeAlynBeFVtDv98kDkyBcjXbfV\nAUQK9PmLAPyixGoH0XIOnG46wCWHJ/nVuhO2tVuUELX9DQBM1NoGVCpfqh0a\new/yv3v2enkVdPNJ3FE/4Em5wst4t+3vBgFEUFxiQHpMqX1/twJyEaZ400G/\nALATTPkUwdQi7BILetapoTLY7QgA7ZKYNC3hlbDR0oaryC5+t7os6Ewf/Z0L\nWRSmmYyFctgnTwm6MMpoZvuWP0ISW9SFSs3QHbuGog2hJq8eLx/x16Kt/Jlk\nUkmPaU3sgp3GAZNQvj9lAEDFrBaHeHUxo894XtTWiKh9izprf5ts5PoDumxJ\nNEfC\r\n=Cpyf\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"name":"nornagon","email":"nornagon@nornagon.net"},{"name":"felixrieseberg","email":"felix@felixrieseberg.com"},{"name":"shanedewael","email":"sdewael@slack-corp.com"},{"name":"slackhq","email":"opensource@slack.com"},{"name":"grantmd","email":"myles@mylesgrant.com"},{"name":"mjsz","email":"matt.schweitz@gmail.com"},{"name":"l12s","email":"npm-l12s@l12s.com"},{"name":"ibu","email":"ibrahim@madha.net"},{"name":"slackhq-admin","email":"mcrocker+slackhq-admin@slack-corp.com"},{"name":"devinfoley","email":"devin@devinfoley.com"},{"name":"roach","email":"roach@roach.wtf"},{"name":"aoberoi","email":"aoberoi@gmail.com"},{"name":"ajm","email":"macdonald.andrew@gmail.com"}],"_npmUser":{"name":"aoberoi","email":"aoberoi@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/rtm-api_5.0.0_1553810493947_0.8186954519856151"},"_hasShrinkwrap":false},"5.0.1":{"name":"@slack/rtm-api","version":"5.0.1","description":"Official library for using the Slack Platform's Real Time Messaging API","author":{"name":"Slack Technologies, Inc."},"license":"MIT","keywords":["slack","rtm-api","bot","client","http","websocket","api","proxy","state","connection"],"main":"dist/index.js","types":"./dist/index.d.ts","engines":{"node":">= 8.9.0","npm":">= 5.5.1"},"repository":{"type":"git","url":"git+https://github.com/slackapi/node-slack-sdk.git"},"homepage":"https://slack.dev/node-slack-sdk/rtm-api","publishConfig":{"access":"public"},"bugs":{"url":"https://github.com/slackapi/node-slack-sdk/issues"},"scripts":{"prepare":"npm run build","build":"npm run build:clean && tsc","build:clean":"shx rm -rf ./dist","lint":"tslint --project .","test":"npm run build && echo \"Tests are not implemented.\" && exit 0"},"dependencies":{"@slack/logger":"^1.0.0","@slack/web-api":"^5.0.1","@types/node":">=8.9.0","@types/p-queue":"^2.3.2","@types/ws":"^5.1.1","eventemitter3":"^3.1.0","finity":"^0.5.4","p-cancelable":"^1.1.0","p-queue":"^2.4.2","ws":"^5.2.0"},"devDependencies":{"shx":"^0.3.2","tslint":"^5.13.1","tslint-config-airbnb":"^5.11.1","typescript":"^3.3.3333"},"gitHead":"0a53364d7cdb6d4485ba30676086bcaaabc46b4e","_id":"@slack/rtm-api@5.0.1","_nodeVersion":"10.15.1","_npmVersion":"lerna/3.13.1/node@v10.15.1+x64 (darwin)","dist":{"integrity":"sha512-M8qcWssFg9SmNUSkxDE230ahl+toRJKRG76PluGL6EqlPcbLqzJYpwPBTPLq6WADYo6yNd6WGGQ4Qtzw/b7rvw==","shasum":"7663f418336c86c9f081890f0d3b4ce8f521d2a3","tarball":"https://registry.npmjs.org/@slack/rtm-api/-/rtm-api-5.0.1.tgz","fileCount":23,"unpackedSize":97119,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcuB1jCRA9TVsSAnZWagAALrYP/jnORd973WhYe5a8/1/s\nbcQUux2kmsGhsUDftLvrAV3NTxQyzrtgqxDp2jbsyAcF9dz/P9ralKeKWdCw\n4LHcThTtzXNaGMl0kzEmx4P8Drg3E5oKN6M7/JEHMD7O/8nzYd2OoVtQllN1\npCU8wT3zm5Sx9dyQ08nmnupyrs4Z+eYKYZFWAmpr/KCawjQ3WZg9kFlBV++3\nNlzBwNvDtpCMYx0sCHwTBFuujeWtpGrWN8dBsc5luSJ488thOjrwEjPsW64x\ngQg3eIneKy8IM7bzYNCLpLsLYCW5fm2qe19ez7l/iVDZNovQB0zR59Ess3Ng\nmSKfW5zJlEff4rkrqhpBKyPfpUH6PfOXBDCcnbPJyRGgQGFSwudGeUw6GnHL\ncKkxi7zK1C250KhBjbFuQpfyHMWk6g6QInghnDiV5Db7SXeL6qPXD5FLa+40\nK++5iY66esEfj2zSmzOWfKqhCiVEC0TnCgQu2Gb0FoWI81d8twczyKgrWLA/\n4uh89whhEeMnLmAfa7JuHYnhUVZuokNi60chiTAYYKOcyNHEsf3gQCwZnM8n\nwUyet87+mJE57yCm4ZtJcJTjAwWMxbcsTCGvBFUED06PT6HiRTPxTbM2z0VI\n46q0EKNM+9jrvpil6oGv3+A2yUGC9ihr3M7TeL/eFgut/ohEiUkEmWZxbYor\n6o+5\r\n=6EC6\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"macdonald.andrew@gmail.com","name":"ajm"},{"email":"aoberoi@gmail.com","name":"aoberoi"},{"email":"devin@devinfoley.com","name":"devinfoley"},{"email":"felix@felixrieseberg.com","name":"felixrieseberg"},{"email":"myles@mylesgrant.com","name":"grantmd"},{"email":"ibrahim@madha.net","name":"ibu"},{"email":"nornagon@nornagon.net","name":"nornagon"},{"email":"roach@roach.wtf","name":"roach"},{"email":"sdewael@slack-corp.com","name":"shanedewael"},{"email":"opensource@slack.com","name":"slackhq"},{"email":"mcrocker+slackhq-admin@slack-corp.com","name":"slackhq-admin"}],"_npmUser":{"name":"aoberoi","email":"aoberoi@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/rtm-api_5.0.1_1555570018885_0.9246176170267331"},"_hasShrinkwrap":false},"5.0.2":{"name":"@slack/rtm-api","version":"5.0.2","description":"Official library for using the Slack Platform's Real Time Messaging API","author":{"name":"Slack Technologies, Inc."},"license":"MIT","keywords":["slack","rtm-api","bot","client","http","websocket","api","proxy","state","connection"],"main":"dist/index.js","types":"./dist/index.d.ts","engines":{"node":">= 8.9.0","npm":">= 5.5.1"},"repository":{"type":"git","url":"git+https://github.com/slackapi/node-slack-sdk.git"},"homepage":"https://slack.dev/node-slack-sdk/rtm-api","publishConfig":{"access":"public"},"bugs":{"url":"https://github.com/slackapi/node-slack-sdk/issues"},"scripts":{"prepare":"npm run build","build":"npm run build:clean && tsc","build:clean":"shx rm -rf ./dist","lint":"tslint --project .","test":"npm run build && echo \"Tests are not implemented.\" && exit 0"},"dependencies":{"@slack/logger":"^1.0.0","@slack/web-api":"^5.1.0","@types/node":">=8.9.0","@types/p-queue":"^2.3.2","@types/ws":"^5.1.1","eventemitter3":"^3.1.0","finity":"^0.5.4","p-cancelable":"^1.1.0","p-queue":"^2.4.2","ws":"^5.2.0"},"devDependencies":{"shx":"^0.3.2","tslint":"^5.13.1","tslint-config-airbnb":"^5.11.1","typescript":"^3.3.3333"},"gitHead":"35b40af1dc28ef40cb00eb9a47f902e73c27b03f","_id":"@slack/rtm-api@5.0.2","_nodeVersion":"12.6.0","_npmVersion":"lerna/3.16.4/node@v12.6.0+x64 (darwin)","dist":{"integrity":"sha512-eKQM3RD5TM4G0+nGsL9NJUT4g9khdI9ACJjbPjHO2cq+KsB1rClct1zNWdF40E8QtlpOL5F9/dSap+H4UHlcRA==","shasum":"b87c71635fa59d306ec78f9e2bc3dfd22b2c6cd5","tarball":"https://registry.npmjs.org/@slack/rtm-api/-/rtm-api-5.0.2.tgz","fileCount":23,"unpackedSize":97119,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdO3WRCRA9TVsSAnZWagAAANIP/2Be4rdYnTGNQEkm/nkS\ng9lcj75Q/VZw1+L2deHoI4p9HPnvbaEHoLjNIWfRBw7bVLX6sruch+M7SHb/\n4YCCpKPhT4KD38/QXdHjsMQzdXvnPx9ieUeuMbW6kUN8YQcWVhcE1jXZv7oN\nG4Q3nQ6aFltdf/53ZJJSyd6307BRNShDqf/+DsAJrWHS2zePPoSgu28RjRJ9\nanQQEysQo2RtbGh2e/deMvAe02LoNKXSFI3b9ACTOCZ+4Qy8y1UkzMCNqKlh\nzxfSItQMM9ATYI+K4VgveC+4E8Ye1+O3ZqGci+fc0ayI7NEAZGoxjXW+wLOT\npGz8WA9rhtBpU/HgLxPiTqqvX6CulvBiS6rp+zU/beTf4LC+R3KV+Oi5ubQQ\na8QXOKKPoUsFGO+a8Am25fCnnZaVgOgaXASftE4vt4HeNHk638o0nGtRkPMh\nkxPhGZO+WUMt/M26zzLiVyDAx8sw7FOrV05xux7MxAeJUwqJJ926c3u1WxZv\nnW55yV0vcURY8k9Kw8PsaIowqIPmyLJ++DsEBdwbZuWnHAq4tjBVzc0zS9M+\nG1Ju1L6d/Xw2dv93Q8czHO0fj6F2+5ZWELxOHHAs/DWRPGAL0q5u4aOzkkDK\nRVdDyfxcai0bQV7FT6ZgoeA+aDGXbMAocLdcKGriRvjM0XWZM5mcP4kjqzpY\nxONg\r\n=ViYU\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"macdonald.andrew@gmail.com","name":"ajm"},{"email":"aoberoi@gmail.com","name":"aoberoi"},{"email":"goghogguy@gmail.com","name":"clavin"},{"email":"devin@devinfoley.com","name":"devinfoley"},{"email":"felix@felixrieseberg.com","name":"felixrieseberg"},{"email":"myles@mylesgrant.com","name":"grantmd"},{"email":"ibrahim@madha.net","name":"ibu"},{"email":"nornagon@nornagon.net","name":"nornagon"},{"email":"roach@roach.wtf","name":"roach"},{"email":"sdewael@slack-corp.com","name":"shanedewael"},{"email":"opensource@slack.com","name":"slackhq"},{"email":"mcrocker+slackhq-admin@slack-corp.com","name":"slackhq-admin"}],"_npmUser":{"name":"clavin","email":"watfordcalvin@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/rtm-api_5.0.2_1564177808571_0.5179971057540187"},"_hasShrinkwrap":false},"5.0.3":{"name":"@slack/rtm-api","version":"5.0.3","description":"Official library for using the Slack Platform's Real Time Messaging API","author":{"name":"Slack Technologies, Inc."},"license":"MIT","keywords":["slack","rtm-api","bot","client","http","websocket","api","proxy","state","connection"],"main":"dist/index.js","types":"./dist/index.d.ts","engines":{"node":">= 8.9.0","npm":">= 5.5.1"},"repository":{"type":"git","url":"git+https://github.com/slackapi/node-slack-sdk.git"},"homepage":"https://slack.dev/node-slack-sdk/rtm-api","publishConfig":{"access":"public"},"bugs":{"url":"https://github.com/slackapi/node-slack-sdk/issues"},"scripts":{"prepare":"npm run build","build":"npm run build:clean && tsc","build:clean":"shx rm -rf ./dist","lint":"tslint --project .","test":"npm run build && echo \"Tests are not implemented.\" && exit 0"},"dependencies":{"@slack/logger":"^1.0.0","@slack/web-api":"^5.1.0","@types/node":">=8.9.0","@types/p-queue":"^2.3.2","@types/ws":"^5.1.1","eventemitter3":"^3.1.0","finity":"^0.5.4","p-cancelable":"^1.1.0","p-queue":"^2.4.2","ws":"^5.2.0"},"devDependencies":{"shx":"^0.3.2","tslint":"^5.13.1","tslint-config-airbnb":"^5.11.1","typescript":"^3.3.3333"},"gitHead":"8a3f777519718ffb87cbde712f75b8d594255f84","_id":"@slack/rtm-api@5.0.3","_nodeVersion":"12.2.0","_npmVersion":"lerna/3.16.4/node@v12.2.0+x64 (darwin)","dist":{"integrity":"sha512-rzNIFst8iuVYyHdE7e3KSrbAtIA7sfS4Pth9ObKUm5KDemX0zyI7YfAijO1kgr1EMriQkjlpKBhlNq9Y+aQr6g==","shasum":"05b60d1655a05e377d6044dbfdf65602ca6bacf1","tarball":"https://registry.npmjs.org/@slack/rtm-api/-/rtm-api-5.0.3.tgz","fileCount":23,"unpackedSize":97119,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdi/AVCRA9TVsSAnZWagAAbdsP+QEgTL/YydK7WEL3KnXp\njFQxFqy5ib4XMy94/tveKKKrVj+Ww8E5VYipHJvTT7Ul7sp7jAuVvCv+nks7\nTHMwlUNeAKGh+RquNXErjuwqqid38VnQYxWu1O3jPzEi5/hcfYrzzmMBU3oX\n65MBqmKI0lYaNUeOb418hNR8UGr55Dw8vl2LxP19ozzCszpgclHPVfKrZNLW\ne5moVK7icJrhjl6RrJU59+msG0Agu4XigrvHNlCSw1Ufe4SqcOo6MB1oFIwl\nHkXWql3/C754SVsAEBhO5eWqB+Y1r8bom2QADuM7sJIF1a/wMorkMdJLfzVs\nkv2ZKqL0wmBCgA7Bcj+1wK7iLhSpjjA5giFUJv1K17Zn35VNLg6ygFshBZ7l\nQJHhx5EAdeAdvXxYCOu57t0WXi2G/ip9FlaLAhMy8zn6t9xjgz6yMtd6epub\nsrPOWKL8/RPy6mIb4JQPfBk2pEndI5x8j7fE0kxBpqcCR/eL0EW2Vi+y2mET\nCjocveB1LDrZ+rafH9tJg1vte8Y7IG6K/fDBtkLPJgaskau2vnWSMS5iRMK9\nf/Nr0F/0qEU/52Nwv3QRpSc4qFr2tdhI449FkO6SpbVBefBWIoWOxrDx5zsc\nIl6YcTVYFN0aU369vq/heevttBLnhbMYyVyWF8UVpxwsNWTT+dGR+wb7Vx1a\nQFyB\r\n=IqgI\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"email":"macdonald.andrew@gmail.com","name":"ajm"},{"email":"aoberoi@gmail.com","name":"aoberoi"},{"email":"devin@devinfoley.com","name":"devinfoley"},{"email":"felix@felixrieseberg.com","name":"felixrieseberg"},{"email":"myles@mylesgrant.com","name":"grantmd"},{"email":"ibrahim@madha.net","name":"ibu"},{"email":"nornagon@nornagon.net","name":"nornagon"},{"email":"roach@roach.wtf","name":"roach"},{"email":"sdewael@slack-corp.com","name":"shanedewael"},{"email":"opensource@slack.com","name":"slackhq"}],"_npmUser":{"name":"aoberoi","email":"aoberoi@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/rtm-api_5.0.3_1569452052761_0.6597319167474751"},"_hasShrinkwrap":false}},"time":{"created":"2019-03-28T22:01:33.838Z","5.0.0":"2019-03-28T22:01:34.073Z","modified":"2019-11-12T23:07:03.906Z","5.0.1":"2019-04-18T06:46:59.003Z","5.0.2":"2019-07-26T21:50:08.752Z","5.0.3":"2019-09-25T22:54:12.866Z"},"maintainers":[{"email":"stevengill97@gmail.com","name":"stevegill"},{"email":"nornagon@nornagon.net","name":"nornagon"},{"email":"felix@felixrieseberg.com","name":"felixrieseberg"},{"email":"sdewael@slack-corp.com","name":"shanedewael"},{"email":"opensource@slack.com","name":"slackhq"},{"email":"myles@mylesgrant.com","name":"grantmd"},{"email":"ibrahim@madha.net","name":"ibu"},{"email":"devin@devinfoley.com","name":"devinfoley"},{"email":"roach@roach.wtf","name":"roach"},{"email":"aoberoi@gmail.com","name":"aoberoi"},{"email":"macdonald.andrew@gmail.com","name":"ajm"}],"description":"Official library for using the Slack Platform's Real Time Messaging API","homepage":"https://slack.dev/node-slack-sdk/rtm-api","keywords":["slack","rtm-api","bot","client","http","websocket","api","proxy","state","connection"],"repository":{"type":"git","url":"git+https://github.com/slackapi/node-slack-sdk.git"},"author":{"name":"Slack Technologies, Inc."},"bugs":{"url":"https://github.com/slackapi/node-slack-sdk/issues"},"license":"MIT","readme":"# Slack Real Time Messaging API\n\n<!-- TODO: per-job badge https://github.com/bjfish/travis-matrix-badges/issues/4 -->\n[![Build Status](https://travis-ci.org/slackapi/node-slack-sdk.svg?branch=master)](https://travis-ci.org/slackapi/node-slack-sdk)\n<!-- TODO: per-flag badge https://docs.codecov.io/docs/flags#section-flag-badges-and-graphs -->\n[![codecov](https://codecov.io/gh/slackapi/node-slack-sdk/branch/master/graph/badge.svg)](https://codecov.io/gh/slackapi/node-slack-sdk)\n<!-- TODO: npm versions with scoped packages: https://github.com/rvagg/nodei.co/issues/24 -->\n\nThe `@slack/rtm-api` package contains a simple, convenient, and configurable client for receiving events and sending simple messages to Slack's [Real Time Messaging API](https://api.slack.com/rtm). Use it in your\napp to stay connected to the Slack platform over a persistent Websocket connection.\n\n## Installation\n\n```shell\n$ npm install @slack/rtm-api\n```\n\n<!-- START: Remove before copying into the docs directory -->\n\n## Usage\n\nThese examples show the most common features of the `RTMClient`. You'll find even more extensive [documentation on the\npackage's website](https://slack.dev/node-slack-sdk/rtm-api).\n\n<!-- END: Remove before copying into the docs directory -->\n\n---\n\n### Initialize the client\n\nThe package exports an `RTMClient` class. Your app will create an instance of the class for each workspace it\ncommunicates with. Creating an instance requires a `token` from Slack. Apps typically connect to the RTM API using a bot\ntoken, which start with `xoxb`. These tokens are created for apps that have a Bot User, so to connect to the RTM API be\nsure to add a Bot User in your app configuration page. Once the app is installed to the development workspace, you'll\nhave a bot token.\n\n```javascript\nconst { RTMClient } = require('@slack/rtm-api');\n\n// Read a token from the environment variables\nconst token = process.env.SLACK_BOT_TOKEN;\n\n// Initialize\nconst rtm = new RTMClient(token);\n```\n\n### Connect to Slack\n\nData from Slack will begin to flow to your program once the client is connected. You'll also be able to send data to\nSlack after the connection is established. Connecting is as easy as calling the `.start()` method. This method returns a\n`Promise` that resolves to the data returned from the [`rtm.connect` Web API\nmethod](https://api.slack.com/methods/rtm.connect).\n\n```javascript\nconst { RTMClient } = require('@slack/rtm-api');\nconst token = process.env.SLACK_BOT_TOKEN;\n\nconst rtm = new RTMClient(token);\n\n(async () => {\n  // Connect to Slack\n  const { self, team } = await rtm.start();\n})();\n```\n\nIt's useful in many apps to keep information about the bot user who you've connected as, as well as the workspace you've\nconnected to. That information has been destructured into the variables `self` and `team` above. If you only need the\nuser ID and team ID, you can look those up any time the client is connected as the `rtm.activeUserId` and\n`rtm.activeTeamId` properties. In fact, if you need to know whether the client is connected or not, you can check the\n`rtm.connected` property.\n\n<details>\n<summary markdown=\"span\">\n<strong><i>Additional connection options</i></strong>\n</summary>\n\nOptions passed to the `.start()` method are passed through as arguments to the [`rtm.connect` Web API\nmethod](https://api.slack.com/methods/rtm.connect). These arguments deal with presence, which is discussed in more\ndetail [on the documentation website](https://slack.dev/node-slack-sdk/rtm-api#presence).\n\n</details>\n\n---\n\n### Listen for an event\n\nApps register functions, called listeners, to be triggered when an event of a specific type is received by the client.\nIf you've used Node's [`EventEmitter`](https://nodejs.org/api/events.html#events_class_eventemitter) pattern\nbefore, then you're already familiar with how this works, since the client is an `EventEmitter`.\n\nThe `event` argument passed to the listener is an object. It's contents corresponds to the [type of\nevent](https://api.slack.com/events) its registered for.\n\n```javascript\nconst { RTMClient } = require('@slack/rtm-api');\nconst token = process.env.SLACK_BOT_TOKEN;\nconst rtm = new RTMClient(token);\n\n// Attach listeners to events by type. See: https://api.slack.com/events/message\nrtm.on('message', (event) => {\n  console.log(event);\n});\n\n(async () => {\n  await rtm.start();\n})();\n```\n\n<details>\n<summary markdown=\"span\">\n<strong><i>Listen for message subtypes</i></strong>\n</summary>\n\nThe `message` event type has a special property called `subtype` to help organize all the messages inside Slack. The\nclient has a convenient shorthand for listening to events of type `message`, but filtered to a specific `subtype`.\nThe shorthand is to add the `::` characters, followed by the name of the subtype, to the event type.\n\n```javascript\nconst { RTMClient } = require('@slack/rtm-api');\nconst token = process.env.SLACK_BOT_TOKEN;\nconst rtm = new RTMClient(token);\n\n// Attach listeners to events by message subtype. See: https://api.slack.com/events/message/channel_purpose\nrtm.on('message::channel_purpose', (event) => {\n  console.log(event);\n});\n\n(async () => {\n  await rtm.start();\n})();\n```\n\n</details>\n\n---\n\n### Send a message\n\nYour app can send simple messages to Slack over the client's connection. In this case, simple means that it cannot\nsend messages that include attachments or blocks, but it can include text, mentions, and links which unfurl.\nThe client has a `.sendMessage(text, conversationId)` method for sending messages to Slack. That method returns a\n`Promise` which resolves once Slack has acknowledged the message with a\n[reply](https://api.slack.com/rtm#handling_responses). The resolved value contains information about the sent message,\nsuch as the `ts` identifier. See [error handling](#handle-errors) for details on how your app should deal with a\n`Promise` rejection.\n\n```javascript\nconst { RTMClient } = require('@slack/rtm-api');\nconst token = process.env.SLACK_BOT_TOKEN;\nconst rtm = new RTMClient(token);\n\n// Listen for users who join a channel that the bot user is a member of\n// See: https://api.slack.com/events/member_joined_channel\nrtm.on('member_joined_channel', async (event) => {\n  try {\n    // Send a welcome message to the same channel where the new member just joined, and mention the user.\n    const reply = await rtm.sendMessage(`Welcome to the channel, <@${event.user}>`, event.channel)\n    console.log('Message sent successfully', reply.ts);\n  } catch (error) {\n    console.log('An error occurred', error);\n  }\n});\n\n(async () => {\n  await rtm.start();\n})();\n```\n\n<details>\n<summary markdown=\"span\">\n<strong><i>Send rich messages using the WebClient</i></strong>\n</summary>\n\nThe Web API's [`chat.postMessage` method](https://api.slack.com/methods/chat.postMessage) is capable of sending [rich\nmessages](https://api.slack.com/messaging/composing/layouts) more advanced layout and interactions. These rich messages\nare more attractive and useful for users of your app. Install and import the `@slack/web-api` package into your app,\ninitialize the `WebClient` class, and use the `.chat.postMessage(options)` method to send a rich message. The example\nabove can be rewritten using the following code:\n\n```javascript\nconst { RTMClient } = require('@slack/rtm-api');\nconst token = process.env.SLACK_BOT_TOKEN;\nconst rtm = new RTMClient(token);\n\n// Import the WebClient, and initialize it with the same bot token\nconst { WebClient } = require('@slack/web-api');\nconst web = new WebClient(token);\n\n// Listen for users who join a channel that the bot user is a member of\n// See: https://api.slack.com/events/member_joined_channel\nrtm.on('member_joined_channel', async (event) => {\n  try {\n    // Send a welcome message with a button to the same channel where the new member just joined.\n    const result = await web.chat.postMessage({\n      blocks: [\n        {\n          type: 'section',\n          text: {\n            type: 'mrkdwn',\n            text: `Welcome to the channel, <@${event.user}>. We're here to help. Let us know if you have an issue.`,\n          },\n          accessory: {\n            type: 'button',\n            text: {\n              type: 'plain_text',\n              text: 'Get Help',\n            },\n            value: 'get_help',\n          },\n        },\n      ],\n      channel: event.channel,\n    });\n    console.log('Message sent successfully', result.ts);\n  } catch (error) {\n    console.log('An error occurred', error);\n  }\n});\n\n(async () => {\n  await rtm.start();\n})();\n```\n\n</details>\n\n<details>\n<summary markdown=\"span\">\n<strong><i>Send a typing indicator</i></strong>\n</summary>\n\nOver the RTM API, your bot user can appear to be typing in Slack before it sends a message (\"{Bot Display Name} is\ntyping\" is shown near the text input). The client has a `.sendTyping(conversationId)` method to allow your bot to\ntrigger the typing indicator. The method returns a `Promise` that resolves when Slack has acknowledged the message. The\n`Promise` doesn't have a resolved value.\n\nIf you decide to use this method, make sure your bot follows up with an actual message. Otherwise, the bot user may\nappear to be typing for a very long time.\n\n```javascript\nconst { RTMClient } = require('@slack/rtm-api');\nconst token = process.env.SLACK_BOT_TOKEN;\nconst rtm = new RTMClient(token);\n\n// Listen for users who join a channel that the bot user is a member of\n// See: https://api.slack.com/events/member_joined_channel\nrtm.on('member_joined_channel', async (event) => {\n  try {\n    // Send a typing indicator, and wait for 3 seconds\n    await rtm.sendTyping(event.channel);\n    await (new Promise((resolve) => setTimeout(resolve, 3000)));\n\n    // Send a message (clears typing indicator)\n    const reply = await rtm.sendMessage(`Welcome to the channel, <@${event.user}>`, event.channel)\n    console.log('Message sent successfully', reply.ts);\n  } catch (error) {\n    console.log('An error occurred', error);\n  }\n});\n\n(async () => {\n  await rtm.start();\n})();\n```\n\n</details>\n\n---\n\n### Lifecycle events\n\nThe client's connection to Slack has a lifecycle. This means the client can be seen as a state machine which transitions\nthrough a few states as it connects, disconnects, reconnects, and synchronizes with Slack. The client emits an event\nfor each state it transitions to throughout its lifecycle. If your app simply needs to know whether the client is\nconnected or not, the `.connected` boolean property can be checked.\n\nIn the table below, the client's states are listed, which are also the names of the events you can use to observe\nthe transition to that state. The table also includes description for the state, and arguments that a listener would\nreceive.\n\n| Event Name      | Arguments | Description |\n|-----------------|-----------------|-------------|\n| `connecting`    |  | The client is in the process of connecting to the platform. |\n| `authenticated` | `(connectData)` - the response from `rtm.connect` or `rtm.start` | The client has authenticated with the platform. This is a sub-state of `connecting`. |\n| `connected`     |  | The client is connected to the platform and incoming events will start being emitted. |\n| `ready`         |  | The client is ready to send outgoing messages. This is a sub-state of `connected` |\n| `disconnecting` |  | The client is no longer connected to the platform and cleaning up its resources. It will soon transition to `disconnected`. |\n| `reconnecting`  |  | The client is no longer connected to the platform and cleaning up its resources. It will soon transition to `connecting`. |\n| `disconnected`  | `(error)` | The client is not connected to the platform. This is a steady state - no attempt to connect is occurring. The `error` argument will be `undefined` when the client initiated the disconnect (normal). |\n\nThe client also emits events that are part of its lifecycle, but aren't states. Instead, they represent specific\nmoments that might be interesting to your app. The following table lists these events, their description, and includes\nthe arguments that a listener would receive.\n\n| Event Name      | Arguments | Description |\n|-----------------|-----------|-------------|\n| `error`         | `(error)` | An error has occurred. See [error handling](#handle-errors) for details. |\n| `slack_event`   | `(eventType, event)` | An incoming Slack event has been received. |\n| `unable_to_rtm_start` | `(error)` | A problem occurred while connecting, a reconnect may or may not occur. |\n\n---\n\n### Handle errors\n\nErrors can happen for many reasons: maybe the token isn't valid, maybe you tried to send a message while the client is\ndisconnected, or maybe you just used a bad argument. In these cases, the returned `Promise` will reject with an `Error`.\nYou should catch the error and use the information it contains to decide how your app can proceed.\n\nEach error contains a `code` property, which you can check against the `ErrorCode` export to understand the kind of\nerror you're dealing with. For example, when Slack responds to your app with an error, that is an\n`ErrorCode.SendMessagePlatformError`. These types of errors provide Slack's response body as the `data` property.\n\n```javascript\n// Import ErrorCode from the package\nconst { RTMClient, ErrorCode } = require('@slack/rtm-api');\nconst token = process.env.SLACK_BOT_TOKEN;\nconst rtm = new RTMClient(token);\n\nrtm.on('member_joined_channel', async (event) => {\n  try {\n    const reply = await rtm.sendMessage(`Welcome to the channel, <@${event.user}>`, event.channel)\n    console.log('Message sent successfully', reply.ts);\n  } catch (error) {\n    // Check the error code, and when its a platform error, log the whole response\n    if (error.code === ErrorCode.SendMessagePlatformError) {\n      console.log(error.data);\n    } else {\n      // Some other error, oh no!\n      console.log('Well, that was unexpected.');\n    }\n  }\n});\n\n(async () => {\n  await rtm.start();\n})();\n```\n\n<details>\n<summary markdown=\"span\">\n<strong><i>More error types</i></strong>\n</summary>\n\nThere are a few more types of errors that you might encounter, each with one of these `code`s:\n\n* `ErrorCode.NoReplyReceivedError`: A message was sent, but because either the connection was reset the there was no\n  reply acknowledging it from the server. You may want to send this message again.\n* `ErrorCode.SendWhileDisconnectedError`: You've attempted to send a message while the client was not connected.\n* `ErrorCode.SendWhileNotReadyError`: You've attempted to send a message when the client was authenticated but not ready\n  for outgoing messages.\n* `ErrorCode.WebsocketError`: The Websocket transport underlying the connection has emitted an error.\n\n</details>\n\n---\n\n### Logging\n\nThe `RTMClient` will log interesting information to the console by default. You can use the `logLevel` to decide how\nmuch information, or how interesting the information needs to be, in order for it to be output. There are a few possible\nlog levels, which you can find in the `LogLevel` export. By default, the value is set to `LogLevel.INFO`. While you're\nin development, its sometimes helpful to set this to the most verbose: `LogLevel.DEBUG`.\n\n```javascript\n// Import LogLevel from the package\nconst { RTMClient, LogLevel } = require('@slack/rtm-api');\nconst token = process.env.SLACK_BOT_TOKEN;\n\n// Log level is one of the options you can set in the constructor\nconst rtm = new RTMClient(token, {\n  logLevel: LogLevel.DEBUG,\n});\n\n(async () => {\n  await rtm.start();\n})();\n```\n\nAll the log levels, in order of most to least information are: `DEBUG`, `INFO`, `WARN`, and `ERROR`.\n\n<details>\n<summary markdown=\"span\">\n<strong><i>Sending log output somewhere besides the console</i></strong>\n</summary>\n\nYou can also choose to have logs sent to a custom logger using the `logger` option. A custom logger needs to implement\nspecific methods (known as the `Logger` interface):\n\n| Method       | Parameters        | Return type |\n|--------------|-------------------|-------------|\n| `setLevel()` | `level: LogLevel` | `void`      |\n| `setName()`  | `name: string`    | `void`      |\n| `debug()`    | `...msgs: any[]`  | `void`      |\n| `info()`     | `...msgs: any[]`  | `void`      |\n| `warn()`     | `...msgs: any[]`  | `void`      |\n| `error()`    | `...msgs: any[]`  | `void`      |\n\nA very simple custom logger might ignore the name and level, and write all messages to a file.\n\n```javascript\nconst { createWriteStream } = require('fs');\nconst logWritable = createWriteStream('/var/my_log_file'); // Not shown: close this stream\n\nconst rtm = new RTMClient(token, {\n  // Creating a logger as a literal object. It's more likely that you'd create a class.\n  logger: {\n    debug(...msgs): { logWritable.write('debug: ' + JSON.stringify(msgs)); },\n    info(...msgs): { logWritable.write('info: ' + JSON.stringify(msgs)); },\n    warn(...msgs): { logWritable.write('warn: ' + JSON.stringify(msgs)); },\n    error(...msgs): { logWritable.write('error: ' + JSON.stringify(msgs)); },\n    setLevel(): { },\n    setName(): { },\n  },\n});\n\n(async () => {\n  await rtm.start();\n})();\n```\n</details>\n\n---\n\n### More\n\n*  User presence subscriptions\n*  Workspace state snapshot on connection\n*  Using a custom agent for proxying\n*  Automatic reconnect\n*  Custom TLS configuration\n*  Custom API URL\n\n---\n\n## Requirements\n\nThis package supports Node v8 LTS and higher. It's highly recommended to use [the latest LTS version of\nnode](https://github.com/nodejs/Release#release-schedule), and the documentation is written using syntax and features\nfrom that version.\n\n## Getting Help\n\nIf you get stuck, we're here to help. The following are the best ways to get assistance working through your issue:\n\n  * [Issue Tracker](http://github.com/slackapi/node-slack-sdk/issues) for questions, feature requests, bug reports and\n    general discussion related to these packages. Try searching before you create a new issue.\n  * [Email us](mailto:developers@slack.com) in Slack developer support: `developers@slack.com`\n  * [Bot Developers Hangout](https://community.botkit.ai/): a Slack community for developers\n    building all types of bots. You can find the maintainers and users of these packages in **#sdk-node-slack-sdk**.\n","readmeFilename":"README.md","_etag":"W/\"940d93227a8b6fdd3711ed585affa0b0\"","_lastModified":"Tue, 12 Nov 2019 23:07:06 GMT"}